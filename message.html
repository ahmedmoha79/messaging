<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Logistics Secure Messaging</title>
    <style>
        /* [Keep ALL your existing styles exactly as they are] */
        /* All your original CSS remains unchanged */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', system-ui, sans-serif;
        }
        body {
            background: #0a0a0a;
            background: linear-gradient(135deg, #1a1a1a 0%, #0a0a0a 100%) fixed;
            color: #ffffff;
            height: 100vh;
            overflow: hidden;
        }
        /* [ALL other CSS rules remain exactly the same] */
    </style>
</head>
<body>
    <!-- [Keep all your existing HTML structure] -->
    <div class="connection-status">Connecting...</div>
    <div class="messaging-container">
        <!-- [All your original HTML remains unchanged] -->
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script>
        // 1. CONFIGURATION (Update these values only)
        const RENDER_URL = "https://messaging-37qg.onrender.com";
        const SUPABASE_URL = "https://twsqvdxhsfvdibhpfvqr.supabase.co";
        const SUPABASE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InR3c3F2ZHhoc2Z2ZGliaHBmdnFyIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDAxNDA2MzUsImV4cCI6MjA1NTcxNjYzNX0.EVjqobvn9fAd4djsBfg1zOlA2CVSeYukmsc_DMhT1b4";

        // 2. GLOBAL VARIABLES (Don't modify these)
        let supabaseClient, realtimeSubscription, presenceChannel, typingTimeout;
        let selectedUser = null, currentUserId = null, session = null;

        // 3. INITIALIZE APP WHEN PAGE LOADS
        document.addEventListener('DOMContentLoaded', async () => {
            session = JSON.parse(localStorage.getItem('session'));
            if (!session) {
                window.location.href = 'login.html';
                return;
            }

            currentUserId = session.user.id;
            initializeRealtime();
            loadUsers();
            setupEventListeners();
            checkConnectionStatus(); // New connection check
        });

        // 4. REAL-TIME FUNCTIONALITY
        async function initializeRealtime() {
            supabaseClient = createClient(SUPABASE_URL, SUPABASE_KEY, {
                global: { headers: { Authorization: `Bearer ${session.access_token}` }
            });

            // Connection monitoring
            const statusElement = document.querySelector('.connection-status');
            supabaseClient.realtime
                .onOpen(() => {
                    statusElement.textContent = 'Connected';
                    statusElement.classList.add('connected');
                    statusElement.classList.remove('disconnected');
                })
                .onClose(() => {
                    statusElement.textContent = 'Reconnecting...';
                    statusElement.classList.remove('connected');
                    statusElement.classList.add('disconnected');
                })
                .onError(() => {
                    statusElement.textContent = 'Connection Error';
                    statusElement.classList.remove('connected');
                    statusElement.classList.add('disconnected');
                });

            // Presence tracking
            presenceChannel = supabaseClient.channel('online-status', {
                config: { presence: { key: currentUserId } }
            }).on('presence', { event: 'sync' }, () => {
                updateOnlineStatus(Object.keys(presenceChannel.presenceState()));
            }).subscribe();

            // Message subscriptions
            realtimeSubscription = supabaseClient.channel('messages')
                .on('postgres_changes', {
                    event: 'INSERT',
                    schema: 'public',
                    table: 'messages',
                    filter: `receiver_id=eq.${currentUserId}`
                }, (payload) => {
                    if (selectedUser?.id === payload.new.sender_id) {
                        addMessageToChat(payload.new.content, false);
                    }
                }).subscribe();

            // Typing indicators
            supabaseClient.channel('typing')
                .on('broadcast', { event: 'typing' }, (payload) => {
                    if (selectedUser?.id === payload.userId) {
                        showTypingIndicator(payload.userId);
                    }
                }).subscribe();
        }

        // 5. USER MANAGEMENT
        async function loadUsers() {
            try {
                showLoading();
                const response = await fetch(`${RENDER_URL}/api/users`, {
                    headers: { 'Authorization': `Bearer ${session.access_token}` }
                });
                
                if (!response.ok) throw new Error('Failed to load users');
                
                const users = await response.json();
                const userList = document.querySelector('.user-list');
                userList.innerHTML = `<div class="search-bar"><input type="text" class="search-input" placeholder="Search team members..."></div>`;

                users.forEach(user => {
                    if (user.id !== currentUserId) {
                        const lastOnline = new Date(user.lastonline);
                        const statusClass = ((Date.now() - lastOnline) / 60000 > 5) ? 'offline' : 'online';
                        const statusText = statusClass === 'online' ? 'Online' : formatLastOnline(lastOnline);
                        
                        const userCard = document.createElement('div');
                        userCard.className = 'user-card';
                        userCard.dataset.userId = user.id;
                        userCard.innerHTML = `
                            <img src="https://ui-avatars.com/api/?name=${
                                encodeURIComponent(user.name.split(' ')[0])}+${
                                encodeURIComponent(user.name.split(' ')[1] || '')}&background=random&length=2" 
                                class="user-avatar" alt="${user.name}">
                            <div class="user-info">
                                <h4>${user.name}</h4>
                                <p>${statusText}</p>
                            </div>
                            <div class="status-indicator ${statusClass}"></div>
                        `;
                        userCard.addEventListener('click', () => selectUser(userCard, user));
                        userList.appendChild(userCard);
                    }
                });

                document.querySelector('.search-input').addEventListener('input', (e) => {
                    const term = e.target.value.toLowerCase();
                    document.querySelectorAll('.user-card').forEach(card => {
                        card.style.display = card.querySelector('h4').textContent.toLowerCase().includes(term) ? 'flex' : 'none';
                    });
                });
            } catch (error) {
                showError('user-list', 'Failed to load users: ' + error.message);
            }
        }

        // 6. MESSAGE HANDLING
        async function selectUser(card, user) {
            document.querySelectorAll('.user-card').forEach(c => c.classList.remove('active'));
            card.classList.add('active');
            selectedUser = { id: user.id, name: user.name };
            document.querySelector('.chat-header h2').textContent = selectedUser.name;
            await loadMessages(user.id);
        }

        async function loadMessages(userId) {
            try {
                const messagesContainer = document.querySelector('.chat-messages');
                messagesContainer.innerHTML = '<div class="loading-state"><div class="loading-spinner"></div><p>Loading messages...</p></div>';
                
                const response = await fetch(`${RENDER_URL}/api/messages/${userId}`, {
                    headers: { 'Authorization': `Bearer ${session.access_token}` }
                });
                
                if (!response.ok) throw new Error('Failed to load messages');
                
                const messages = await response.json();
                messagesContainer.innerHTML = '';
                messages.forEach(msg => addMessageToChat(msg.content, msg.sender_id === currentUserId));
            } catch (error) {
                showError('chat-messages', 'Failed to load messages: ' + error.message);
            }
        }

        async function sendMessage(receiverId, content) {
            try {
                showSendLoading();
                const response = await fetch(`${RENDER_URL}/api/messages`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${session.access_token}`
                    },
                    body: JSON.stringify({ receiver_id: receiverId, content })
                });
                
                if (!response.ok) throw new Error('Failed to send message');
                
                addMessageToChat(content, true);
                presenceChannel.send({ type: 'broadcast', event: 'stopped-typing', payload: { userId: currentUserId } });
            } catch (error) {
                alert('Send failed: ' + error.message);
            } finally {
                hideSendLoading();
            }
        }

        // 7. HELPER FUNCTIONS
        function addMessageToChat(content, isSent) {
            const messagesContainer = document.querySelector('.chat-messages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${isSent ? 'sent' : 'received'}`;
            messageDiv.innerHTML = `
                <div class="message-content">
                    <p>${content}</p>
                    <span class="message-time">${
                        new Date().toLocaleString([], {
                            hour: '2-digit', 
                            minute:'2-digit', 
                            month: 'short', 
                            day: 'numeric'
                        })
                    }</span>
                </div>
            `;
            messagesContainer.appendChild(messageDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        function showTypingIndicator(userId) {
            const partner = document.querySelector(`[data-user-id="${userId}"] h4`);
            if (partner) {
                document.getElementById('partnerName').textContent = partner.textContent;
                const indicator = document.getElementById('typingIndicator');
                indicator.style.opacity = '1';
                clearTimeout(typingTimeout);
                typingTimeout = setTimeout(() => indicator.style.opacity = '0', 2000);
            }
        }

        function updateOnlineStatus(onlineUserIds) {
            document.querySelectorAll('.user-card').forEach(card => {
                const statusIndicator = card.querySelector('.status-indicator');
                statusIndicator.classList.toggle('online', onlineUserIds.includes(card.dataset.userId));
                statusIndicator.classList.toggle('offline', !onlineUserIds.includes(card.dataset.userId));
            });
            document.getElementById('onlineCount').textContent = `${onlineUserIds.length} online`;
        }

        function formatLastOnline(date) {
            const diff = (Date.now() - date) / 60000;
            return diff < 60 ? `${Math.floor(diff)}m ago` : 
                   diff < 1440 ? `${Math.floor(diff/60)}h ago` : 
                   `${Math.floor(diff/1440)}d ago`;
        }

        function checkConnectionStatus() {
            const status = document.querySelector('.connection-status');
            if (!navigator.onLine) {
                status.textContent = 'Offline - Reconnect required';
                status.classList.remove('connected');
                status.classList.add('disconnected');
            }
        }

        function showLoading() {
            document.querySelector('.user-list').innerHTML = `
                <div class="search-bar">
                    <input type="text" class="search-input" placeholder="Search team members...">
                </div>
                <div class="loading-state">
                    <div class="loading-spinner"></div>
                    <p>Loading users...</p>
                </div>
            `;
        }

        function showError(container, message) {
            document.querySelector(`.${container}`).innerHTML = `
                <div class="error-state">
                    <p>${message}</p>
                    <button onclick="window.location.reload()">Retry</button>
                </div>
            `;
        }

        function showSendLoading() {
            const btn = document.querySelector('.send-button');
            btn.disabled = true;
            btn.textContent = 'Sending...';
        }

        function hideSendLoading() {
            const btn = document.querySelector('.send-button');
            btn.disabled = false;
            btn.textContent = 'Send';
        }

        // 8. EVENT LISTENERS
        function setupEventListeners() {
            // Send message
            document.querySelector('.send-button').addEventListener('click', async () => {
                const input = document.querySelector('.message-input');
                const content = input.value.trim();
                if (!selectedUser) return alert('Select a user first');
                if (!content) return alert('Message cannot be empty');
                await sendMessage(selectedUser.id, content);
                input.value = '';
            });

            // Enter key sends message
            document.querySelector('.message-input').addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    document.querySelector('.send-button').click();
                }
            });

            // Typing detection
            document.querySelector('.message-input').addEventListener('input', () => {
                if (!selectedUser) return;
                presenceChannel.send({
                    type: 'broadcast',
                    event: 'typing',
                    payload: { userId: currentUserId, partnerId: selectedUser.id }
                });
                clearTimeout(typingTimeout);
                typingTimeout = setTimeout(() => {
                    presenceChannel.send({
                        type: 'broadcast',
                        event: 'stopped-typing',
                        payload: { userId: currentUserId }
                    });
                }, 1000);
            });

            // Network detection
            window.addEventListener('online', checkConnectionStatus);
            window.addEventListener('offline', checkConnectionStatus);
        }
    </script>
</body>
</html>