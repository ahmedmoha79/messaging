<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Logistics Secure Messaging</title>
    <style>
        /* [Your existing CSS remains exactly the same] */
    </style>
</head>
<body>
    <!-- [Your existing HTML structure remains exactly the same] -->

    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script>
        // Configuration
        const SUPABASE_URL = "https://twsqvdxhsfvdibhpfvqr.supabase.co";
        const SUPABASE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InR3c3F2ZHhoc2Z2ZGliaHBmdnFyIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDAxNDA2MzUsImV4cCI6MjA1NTcxNjYzNX0.EVjqobvn9fAd4djsBfg1zOlA2CVSeYukmsc_DMhT1b4";
        
        // Enhanced State Management
        const appState = {
            supabaseClient: null,
            presenceChannel: null,
            messagesChannel: null,
            typingTimeout: null,
            selectedUser: null,
            currentUserId: null,
            session: null,
            unreadMessages: {},
            isTyping: false,
            lastTypingTime: 0,
            tabId: `tab-${Math.random().toString(36).substring(2, 10)}`,
            lastHeartbeat: 0,
            onlineUsers: new Set(),
            userStatusCache: {}
        };

        // Main Initialization
        document.addEventListener('DOMContentLoaded', async () => {
            try {
                await initializeApplication();
            } catch (error) {
                handleCriticalError(error);
            }
        });

        async function initializeApplication() {
            showSessionCheck();
            await initializeSupabase();
            await verifySession();
            initializeUI();
            await loadInitialData();
            setupEventListeners();
            await initializeRealtime();
            startStatusMonitor();
        }

        // Supabase Initialization
        async function initializeSupabase() {
            appState.supabaseClient = supabase.createClient(SUPABASE_URL, SUPABASE_KEY, {
                auth: {
                    persistSession: true,
                    autoRefreshToken: true,
                    detectSessionInUrl: false,
                    storage: {
                        getItem: (key) => localStorage.getItem(key) || 
                                localStorage.getItem(`sb-${SUPABASE_URL.split('//')[1].split('.')[0]}-auth-token`),
                        setItem: (key, value) => localStorage.setItem(key, value),
                        removeItem: (key) => localStorage.removeItem(key)
                    }
                }
            });
        }

        // Session Management
        async function verifySession() {
            const { data: { session }, error } = await appState.supabaseClient.auth.getSession();
            if (error || !session) {
                const storedSession = localStorage.getItem(`sb-${SUPABASE_URL.split('//')[1].split('.')[0]}-auth-token`);
                if (storedSession) {
                    try {
                        const parsed = JSON.parse(storedSession);
                        await appState.supabaseClient.auth.setSession({
                            access_token: parsed.access_token,
                            refresh_token: parsed.refresh_token
                        });
                        const { data: { session: newSession } } = await appState.supabaseClient.auth.getSession();
                        if (!newSession) throw new Error("Session recovery failed");
                        appState.session = newSession;
                    } catch (e) {
                        console.error("Session recovery error:", e);
                        redirectToLogin();
                    }
                } else {
                    redirectToLogin();
                }
            } else {
                appState.session = session;
            }

            const { data: { user } } = await appState.supabaseClient.auth.getUser();
            if (!user) throw new Error("User verification failed");
            appState.currentUserId = user.id;
        }

        function redirectToLogin() {
            window.location.href = 'login.html';
        }

        // UI Management
        function initializeUI() {
            document.querySelector('.session-check').style.display = 'none';
            document.querySelector('.messaging-container').style.display = 'flex';
            document.querySelector('.message-input').disabled = false;
            document.querySelector('.send-button').disabled = false;
        }

        function showSessionCheck() {
            document.querySelector('.session-check').style.display = 'flex';
        }

        // Data Loading
        async function loadInitialData() {
            await Promise.all([loadUsers(), updateLastOnline()]);
        }

        async function loadUsers() {
            try {
                showLoadingState();
                
                const { data: users, error } = await appState.supabaseClient
                    .from('users')
                    .select('id, name, lastonline')
                    .neq('id', appState.currentUserId)
                    .order('lastonline', { ascending: false });
                
                if (error) throw error;
                
                renderUserList(users);
            } catch (error) {
                showError('user-list', 'Failed to load users. Please refresh.');
                console.error('User load error:', error);
            }
        }

        function renderUserList(users) {
            const userList = document.querySelector('.user-list');
            userList.innerHTML = `
                <div class="search-bar">
                    <input type="text" class="search-input" placeholder="Search team members...">
                </div>
            `;

            if (!users.length) {
                userList.innerHTML += `<p class="empty-state">No other users found</p>`;
                return;
            }

            users.forEach(user => {
                const isOnline = appState.onlineUsers.has(user.id);
                const lastSeen = user.lastonline ? new Date(user.lastonline) : null;
                const statusText = isOnline ? 'Online' : formatLastOnline(lastSeen);
                
                const userCard = document.createElement('div');
                userCard.className = `user-card ${isOnline ? 'online' : ''}`;
                userCard.dataset.userId = user.id;
                userCard.innerHTML = `
                    <img src="https://ui-avatars.com/api/?name=${encodeURIComponent(user.name)}&background=random" 
                         class="user-avatar" alt="${user.name}">
                    <div class="user-info">
                        <h4>${user.name}</h4>
                        <p class="status-text">${statusText}</p>
                    </div>
                    ${appState.unreadMessages[user.id] ? 
                      `<div class="unread-badge">${appState.unreadMessages[user.id]}</div>` : ''}
                    <div class="status-indicator ${isOnline ? 'online' : 'offline'}"></div>
                `;
                userCard.addEventListener('click', () => selectUser(user));
                userList.appendChild(userCard);
                
                // Cache the status element for quick updates
                appState.userStatusCache[user.id] = {
                    element: userCard.querySelector('.status-text'),
                    indicator: userCard.querySelector('.status-indicator')
                };
            });

            updateOnlineCount();
            setupSearch();
        }

        // Realtime Communication
        async function initializeRealtime() {
            updateConnectionStatus("Connecting...");
            
            try {
                // Clean up existing channels
                if (appState.presenceChannel) appState.supabaseClient.removeChannel(appState.presenceChannel);
                if (appState.messagesChannel) appState.supabaseClient.removeChannel(appState.messagesChannel);

                // Enhanced Presence Channel
                appState.presenceChannel = appState.supabaseClient.channel('presence-channel', {
                    config: {
                        presence: {
                            key: appState.tabId,
                            heartbeatIntervalMs: 10000,
                            heartbeatTimeoutMs: 30000
                        }
                    }
                })
                .on('presence', { event: 'sync' }, () => {
                    const state = appState.presenceChannel.presenceState();
                    const currentUsers = new Set();
                    
                    Object.values(state).forEach(entries => {
                        entries.forEach(entry => {
                            if (entry.user_id) currentUsers.add(entry.user_id);
                        });
                    });
                    
                    updatePresenceState(currentUsers);
                })
                .on('broadcast', { event: 'typing' }, ({ payload }) => {
                    if (payload.receiverId === appState.currentUserId) {
                        showTypingIndicator(payload.senderId);
                    }
                });

                // Messages Channel
                appState.messagesChannel = appState.supabaseClient.channel('messages-channel')
                    .on('postgres_changes', {
                        event: '*',
                        schema: 'public',
                        table: 'messages',
                        filter: `or(receiver_id=eq.${appState.currentUserId},sender_id=eq.${appState.currentUserId})`
                    }, handleMessageChange)
                    .subscribe();

                // Subscribe to presence channel last to ensure proper initialization
                await appState.presenceChannel.subscribe(async (status) => {
                    if (status === 'SUBSCRIBED') {
                        await appState.presenceChannel.track({
                            user_id: appState.currentUserId,
                            online_at: new Date().toISOString(),
                            tab_id: appState.tabId
                        });
                        updateConnectionStatus("Connected");
                    }
                });

                // Error handling
                appState.presenceChannel
                    .on('CLOSE', () => setTimeout(initializeRealtime, 3000))
                    .on('ERROR', (err) => {
                        console.error("Presence error:", err);
                        setTimeout(initializeRealtime, 5000);
                    });

            } catch (error) {
                console.error("Realtime init error:", error);
                setTimeout(initializeRealtime, 5000);
            }
        }

        function updatePresenceState(currentUsers) {
            // Update global online state
            appState.onlineUsers = currentUsers;
            
            // Update UI for each user
            Object.keys(appState.userStatusCache).forEach(userId => {
                const isOnline = currentUsers.has(userId);
                const cache = appState.userStatusCache[userId];
                
                if (cache) {
                    // Update status text to always show last online time
                    const userData = appState.supabaseClient.from('users').select('lastonline').eq('id', userId).single();
                    userData.then(({ data }) => {
                        if (data) {
                            const lastOnline = data.lastonline ? new Date(data.lastonline) : null;
                            cache.element.textContent = isOnline ? 'Online' : formatLastOnline(lastOnline);
                            cache.indicator.className = `status-indicator ${isOnline ? 'online' : 'offline'}`;
                        }
                    });
                }
            });
            
            updateOnlineCount();
        }

        function handleMessageChange(payload) {
            const message = payload.new;
            
            // If message belongs to current chat
            if (appState.selectedUser && 
                [message.sender_id, message.receiver_id].includes(appState.selectedUser.id)) {
                processCurrentChatMessage(message);
            } 
            // Otherwise handle as notification
            else if (message.receiver_id === appState.currentUserId) {
                processNewMessageNotification(message);
            }
        }

        function processCurrentChatMessage(message) {
            const isSent = message.sender_id === appState.currentUserId;
            
            addMessageToChat(
                message.content,
                isSent,
                message.created_at,
                message.id,
                message.status
            );
            
            // Mark as read if we're the receiver
            if (!isSent && message.status !== 'read') {
                markMessageAsRead(message.id);
            }
        }

        function processNewMessageNotification(message) {
            incrementUnreadCount(message.sender_id);
            
            // Optional: Show desktop notification
            if (Notification.permission === 'granted' && document.visibilityState !== 'visible') {
                const senderName = appState.userStatusCache[message.sender_id]?.element?.parentElement?.querySelector('h4')?.textContent || 'Someone';
                new Notification(`New message from ${senderName}`, {
                    body: message.content.length > 50 ? 
                          `${message.content.substring(0, 50)}...` : message.content
                });
            }
        }

        // Message Management
        async function selectUser(user) {
            // Clear previous selection
            document.querySelectorAll('.user-card').forEach(c => c.classList.remove('active'));
            
            // Set new selection
            const userCard = document.querySelector(`[data-user-id="${user.id}"]`);
            if (userCard) userCard.classList.add('active');
            
            // Clear unread count
            if (appState.unreadMessages[user.id]) {
                delete appState.unreadMessages[user.id];
                const badge = userCard.querySelector('.unread-badge');
                if (badge) badge.remove();
            }
            
            // Update UI
            appState.selectedUser = { id: user.id, name: user.name };
            document.querySelector('.chat-header h2').textContent = user.name;
            
            // Load messages
            await loadMessages(user.id);
        }

        async function loadMessages(userId) {
            try {
                showMessagesLoading();
                
                const { data: messages, error } = await appState.supabaseClient
                    .from('messages')
                    .select('*')
                    .or(`and(sender_id.eq.${appState.currentUserId},receiver_id.eq.${userId}),
                         and(sender_id.eq.${userId},receiver_id.eq.${appState.currentUserId})`)
                    .order('created_at', { ascending: true });
                
                if (error) throw error;
                
                renderMessages(messages);
                
                // Mark any unread messages as read
                const unreads = messages.filter(m => 
                    m.receiver_id === appState.currentUserId && m.status !== 'read'
                );
                if (unreads.length) {
                    await markMessagesAsRead(unreads.map(m => m.id));
                }
                
            } catch (error) {
                showError('chat-messages', 'Failed to load messages. Please try again.');
                console.error('Message load error:', error);
            }
        }

        function renderMessages(messages) {
            const container = document.querySelector('.chat-messages');
            container.innerHTML = '';
            
            if (!messages.length) {
                container.innerHTML = '<div class="empty-conversation">Start a new conversation!</div>';
                return;
            }
            
            messages.forEach(msg => {
                addMessageToChat(
                    msg.content,
                    msg.sender_id === appState.currentUserId,
                    msg.created_at,
                    msg.id,
                    msg.status
                );
            });
            
            container.scrollTop = container.scrollHeight;
        }

        async function sendMessage(receiverId, content) {
            if (!content.trim()) return;
            
            try {
                showSendLoading();
                
                const { data: message, error } = await appState.supabaseClient
                    .from('messages')
                    .insert([{
                        sender_id: appState.currentUserId,
                        receiver_id: receiverId,
                        content: content.trim(),
                        status: 'sent'
                    }])
                    .select()
                    .single();
                
                if (error) throw error;
                
                // Optimistically add to UI
                addMessageToChat(
                    content.trim(),
                    true,
                    new Date().toISOString(),
                    message.id,
                    'sent'
                );
                
                // Update presence
                await updateLastOnline();
                
                // Notify other user
                await appState.presenceChannel.send({
                    type: 'broadcast',
                    event: 'message-sent',
                    payload: {
                        senderId: appState.currentUserId,
                        receiverId: receiverId,
                        messageId: message.id
                    }
                });
                
            } catch (error) {
                showError('chat-messages', 'Failed to send message. Please try again.');
                console.error('Send error:', error);
            } finally {
                hideSendLoading();
            }
        }

        function addMessageToChat(content, isSent, timestamp, messageId, status) {
            const container = document.querySelector('.chat-messages');
            
            // Clear loading state if present
            if (container.querySelector('.loading-state')) {
                container.innerHTML = '';
            }
            
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${isSent ? 'sent' : 'received'}`;
            if (messageId) messageDiv.dataset.messageId = messageId;
            
            messageDiv.innerHTML = `
                <div class="message-content">
                    <p>${content}</p>
                    <span class="message-time">
                        ${new Date(timestamp).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}
                        ${isSent ? `<span class="message-status">${getStatusText(status)}</span>` : ''}
                    </span>
                </div>
            `;
            
            container.appendChild(messageDiv);
            container.scrollTop = container.scrollHeight;
        }

        // Status Management
        async function updateLastOnline() {
            try {
                const now = new Date().toISOString();
                await appState.supabaseClient
                    .from('users')
                    .update({ lastonline: now })
                    .eq('id', appState.currentUserId);
                appState.lastHeartbeat = Date.now();
            } catch (error) {
                console.error('Last online update failed:', error);
            }
        }

        function startStatusMonitor() {
            // Update every 20 seconds
            setInterval(() => {
                if (document.visibilityState === 'visible') {
                    updateLastOnline();
                }
            }, 20000);
            
            // Initial update
            updateLastOnline();
        }

        // UI Helpers
        function showLoadingState() {
            document.querySelector('.user-list').innerHTML = `
                <div class="search-bar">
                    <input type="text" class="search-input" placeholder="Search team members...">
                </div>
                <div class="loading-state">
                    <div class="loading-spinner"></div>
                    <p>Loading users...</p>
                </div>
            `;
        }

        function showMessagesLoading() {
            document.querySelector('.chat-messages').innerHTML = `
                <div class="loading-state">
                    <div class="loading-spinner"></div>
                    <p>Loading messages...</p>
                </div>
            `;
        }

        function showError(container, message) {
            const element = document.querySelector(`.${container}`);
            if (element) {
                element.innerHTML = `
                    <div class="error-state">
                        <p>${message}</p>
                        <button onclick="window.location.reload()">Retry</button>
                    </div>
                `;
            }
        }

        function showSendLoading() {
            const btn = document.querySelector('.send-button');
            if (btn) {
                btn.disabled = true;
                btn.textContent = 'Sending...';
            }
        }

        function hideSendLoading() {
            const btn = document.querySelector('.send-button');
            if (btn) {
                btn.disabled = false;
                btn.textContent = 'Send';
            }
        }

        function updateConnectionStatus(message, isError = false) {
            const element = document.querySelector('.connection-status');
            if (element) {
                element.textContent = message;
                element.classList.toggle('connected', !isError);
            }
        }

        function updateOnlineCount() {
            const element = document.getElementById('onlineCount');
            if (element) {
                element.textContent = `${appState.onlineUsers.size} online`;
            }
        }

        function showTypingIndicator(userId) {
            const partnerElement = document.querySelector(`[data-user-id="${userId}"] h4`);
            if (partnerElement) {
                const indicator = document.getElementById('typingIndicator');
                const nameElement = document.getElementById('partnerName');
                
                nameElement.textContent = partnerElement.textContent;
                indicator.style.opacity = '1';
                
                clearTimeout(appState.typingTimeout);
                appState.typingTimeout = setTimeout(() => {
                    indicator.style.opacity = '0';
                }, 2000);
            }
        }

        function incrementUnreadCount(userId) {
            appState.unreadMessages[userId] = (appState.unreadMessages[userId] || 0) + 1;
            
            const userCard = document.querySelector(`[data-user-id="${userId}"]`);
            if (userCard) {
                let badge = userCard.querySelector('.unread-badge');
                if (!badge) {
                    badge = document.createElement('div');
                    badge.className = 'unread-badge';
                    userCard.appendChild(badge);
                }
                badge.textContent = appState.unreadMessages[userId];
            }
        }

        // Utility Functions
        function formatLastOnline(date) {
            if (!date) return 'Never online';
            
            const diff = (Date.now() - date.getTime()) / 60000; // minutes
            
            if (diff < 1) return 'Just now';
            if (diff < 60) return `${Math.floor(diff)}m ago`;
            if (diff < 1440) return `${Math.floor(diff/60)}h ago`;
            return `${Math.floor(diff/1440)}d ago`;
        }

        function getStatusText(status) {
            switch (status) {
                case 'delivered': return '✓✓';
                case 'read': return '✓✓✓';
                default: return '✓';
            }
        }

        function setupSearch() {
            const searchInput = document.querySelector('.search-input');
            if (searchInput) {
                searchInput.addEventListener('input', (e) => {
                    const term = e.target.value.toLowerCase();
                    document.querySelectorAll('.user-card').forEach(card => {
                        const name = card.querySelector('h4').textContent.toLowerCase();
                        card.style.display = name.includes(term) ? 'flex' : 'none';
                    });
                });
            }
        }

        function handleCriticalError(error) {
            console.error("Critical error:", error);
            document.querySelector('.session-check').innerHTML = `
                <h2>Application Error</h2>
                <p style="color: #ff4444; margin: 20px 0;">${error.message}</p>
                <div style="display: flex; gap: 10px;">
                    <button onclick="window.location.reload()" 
                            style="padding: 10px 20px; background: #00ff88; border: none; border-radius: 5px; font-weight: bold;">
                        Refresh
                    </button>
                    <button onclick="window.location.href='login.html'" 
                            style="padding: 10px 20px; background: #444; border: none; border-radius: 5px; font-weight: bold; color: white;">
                        Go to Login
                    </button>
                </div>
            `;
        }

        // Event Listeners
        function setupEventListeners() {
            // Message sending
            const sendButton = document.querySelector('.send-button');
            const messageInput = document.querySelector('.message-input');
            
            if (sendButton && messageInput) {
                sendButton.addEventListener('click', handleSendMessage);
                messageInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        handleSendMessage();
                    }
                });
                
                // Typing indicator
                messageInput.addEventListener('input', handleTyping);
            }

            // Network status
            window.addEventListener('online', handleNetworkOnline);
            window.addEventListener('offline', handleNetworkOffline);
            
            // Page visibility
            document.addEventListener('visibilitychange', handleVisibilityChange);
            
            // Before unload
            window.addEventListener('beforeunload', cleanupBeforeUnload);
        }

        async function handleSendMessage() {
            const input = document.querySelector('.message-input');
            const content = input.value.trim();
            
            if (!appState.selectedUser || !content) return;
            
            await sendMessage(appState.selectedUser.id, content);
            input.value = '';
            input.focus();
        }

        function handleTyping() {
            if (!appState.selectedUser || !appState.presenceChannel) return;
            
            const now = Date.now();
            if (!appState.isTyping) {
                appState.isTyping = true;
                appState.presenceChannel.send({
                    type: 'broadcast',
                    event: 'typing',
                    payload: {
                        senderId: appState.currentUserId,
                        receiverId: appState.selectedUser.id
                    }
                });
            }
            
            appState.lastTypingTime = now;
            
            // Stop typing after 1 second of inactivity
            setTimeout(() => {
                if (Date.now() - appState.lastTypingTime > 1000 && appState.isTyping) {
                    appState.isTyping = false;
                    appState.presenceChannel.send({
                        type: 'broadcast',
                        event: 'stopped-typing',
                        payload: { userId: appState.currentUserId }
                    });
                }
            }, 1000);
        }

        function handleNetworkOnline() {
            updateConnectionStatus("Reconnecting...");
            initializeRealtime();
        }

        function handleNetworkOffline() {
            updateConnectionStatus("Offline - No connection", true);
        }

        function handleVisibilityChange() {
            if (document.visibilityState === 'visible') {
                initializeRealtime();
                updateLastOnline();
            }
        }

        function cleanupBeforeUnload() {
            if (appState.presenceChannel) {
                appState.supabaseClient.removeChannel(appState.presenceChannel);
            }
            if (appState.messagesChannel) {
                appState.supabaseClient.removeChannel(appState.messagesChannel);
            }
        }

        // Request notification permission
        if ('Notification' in window && Notification.permission !== 'denied') {
            Notification.requestPermission();
        }
    </script>
</body>
</html>